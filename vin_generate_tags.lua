local dt = require "darktable"
local du = require "lib/dtutils"
local df = require "lib/dtutils.file"
local dsys = require "lib/dtutils.system"

local MODULE_NAME = "AITagGenerator" -- make sure this is unique, no spaces, no special characters   
local EVENT_NAME = "AItaggenerator" -- must be unique for this script
local EVENT_TYPE = "shortcut" -- the event we want (keyboard shortcut)

du.check_min_api_version("7.0.0", MODULE_NAME)

-- https://www.darktable.org/lua-api/index.html#darktable_gettext
local gettext = dt.gettext.gettext

local function _(msgid)
    return gettext(msgid)
end

-- return data structure for script_manager
local script_data = {}

script_data.metadata = {
    name = "AITagsGenerator",
    purpose = "Generate appropriate tags for images with an LLM",
    author = "Vineeth Kartha",
    help = "abcd" -- this seems important
}

-- script_manager integration to allow a script to be removed
-- without restarting darktable
local function destroy()
    pcall(dt.destroy_event, EVENT_NAME, EVENT_TYPE)
    dt.print("Cleaned up " .. EVENT_NAME)
end

-- set the destroy routine so that script_manager can call it when
-- it's time to destroy the script and then return the data to 
-- script_manager
script_data.destroy = destroy


--- Parses an AI-generated text file and extracts tags, caption, and writeup sections.
-- The file is expected to contain sections labeled "TAGS:", "CAPTION:", and "WRITEUP:".
-- Numbering before section headers (e.g., "1. TAGS:") is optional and will be removed.
--
-- @param filepath string: The path to the AI-generated text file.
-- @return table: A table of tags (strings) extracted from the "TAGS:" section.
-- @return string: The caption text extracted from the "CAPTION:" section.
-- @return string: The writeup text extracted from the "WRITEUP:" section.
local function parse_ai_file(filepath)
  local file = io.open(filepath, "r")
  if not file then
    dt.print_error("Could not open file: " .. filepath)
    return {}, "", ""
  end

  local content = file:read("*all")
  file:close()

  -- Normalize line breaks
  content = content:gsub("\r\n", "\n")

  -- Remove optional numbering like "1.   TAGS:" or "23. CAPTION:"
  content = content:gsub("%s*%d+%.%s*([A-Z]+:)", "%1")

  -- Extract sections robustly
  --[[
    Extracts specific sections from the 'content' string using Lua pattern matching:
      - 'tags_section': Captures the text between "TAGS:" and "CAPTION:".
      - 'caption_section': Captures the text between "CAPTION:" and "WRITEUP:".
      - 'writeup_section': Captures the text after "WRITEUP:" until the end of the string.
    If a section is not found, it defaults to an empty string.
  ]]
  local tags_section = content:match("TAGS:(.-)CAPTION:") or ""
  local caption_section = content:match("CAPTION:(.-)WRITEUP:") or ""
  local writeup_section = content:match("WRITEUP:(.+)$") or ""

  -- Process tags into a table
  local tags = {}
  for word in string.gmatch(tags_section, "([^,]+)") do
    table.insert(tags, word:match("^%s*(.-)%s*$")) -- trim spaces
  end

  -- Trim leading/trailing whitespace
  local caption = caption_section:match("^%s*(.-)%s*$")
  local writeup = writeup_section:match("^%s*(.-)%s*$")

  return tags, caption, writeup
end


local function convert_to_temp_jpg(image)
  local temp_file = os.tmpname() .. ".jpg"
  local jpeg_exporter = dt.new_format("jpeg")
  jpeg_exporter:write_image(image, temp_file, true)
  return temp_file
end

local function generate_tags_with_ai_1(image)
  local jpegfile = convert_to_temp_jpg(image)
  local prompt = "You are an expert in image recognition and tagging. Describe the image in detail and generate relevant tags. Format the output as: TAGS: tag1, tag2, tag3 CAPTION: A brief caption WRITEUP: A detailed writeup about the image."
  local LLM = "gemma3:4b"
  local cmd = "ollama run ".. LLM .. prompt .. jpegfile
  dt.print_log("Running: " .. cmd)
end


-- This function will generate tags using AI.
-- It requires the getTagsFromAI.py script to be in the same folder as this script
-- Also ollama and llava should be available locally on the system
--- Generates tags, caption, and writeup for a given image using an external AI Python script.
-- This function constructs and executes a command to run a Python script that analyzes the image
-- and writes the results to a text file. It then reads and parses the result file to extract tags,
-- a caption, and a writeup.
-- @param image (table) The image object containing at least 'path' and 'filename' fields.
-- @return tags (table or nil) The list of tags generated by the AI, or nil if generation failed.
-- @return caption (string or nil) The caption generated by the AI, or nil if generation failed.
-- @return writeup (string or nil) The writeup generated by the AI, or nil if generation failed.
local function generate_tags_title_description_with_ai(image)
  local PYTHON = "python.exe"
  local SCRIPT = "\"C:\\Users\\Admin\\AppData\\Local\\darktable\\lua\\darktableluascripts\\getTagsFromAI.py\""
  local tags =""
  local caption =""
  local writeup =""
-- Raw paths (no quotes for Lua functions)
  local IMGFILE_PATH = image.path .. "\\" .. image.filename
  local RESULTFILE_PATH = image.path .. "\\" .. df.get_basename(image.filename) .. "_ai.txt"

  -- Quoted paths (for subprocess)
  local IMGFILE = "\"" .. IMGFILE_PATH .. "\""
  local RESULTFILE = "\"" .. RESULTFILE_PATH .. "\""

  local cmd = PYTHON .. " " .. SCRIPT .. " " .. IMGFILE .. " " .. RESULTFILE
  dt.print_log("Running: " .. cmd)

  dt.control.execute(cmd)

  if not df.check_if_file_exists(RESULTFILE_PATH) then
    dt.print_error("AI tag file was not generated: " .. RESULTFILE)
    return tags, caption, writeup
  end

  -- Read and parse the result file
  tags, caption, writeup = parse_ai_file(RESULTFILE_PATH)
  return tags, caption, writeup
end
-- this function wll call the tag generation function and attach the tags to the images
local function generate_ai_tags_and_attach(images)
  local job = dt.gui.create_job('Generating AI tags to '.. #images .. " images", true)
  for index, image in ipairs(images) do
    local tags, caption, writeup = generate_tags_title_description_with_ai(image)
    job.percent = index/#images
    dt.print_log(job.percent)
    image.title = caption
    image.description = writeup
    for _, tag in ipairs(tags) do
      dt.print_log("Attaching tag " .. tag .. " to image " .. image.filename)
      local dt_tag = dt.tags.create(tag) -- create or fetch existing tag    
      dt.tags.attach(dt_tag, image) -- attach tag object to image
    end
    dt.print("Attached tags to " .. #images .. " images")
  end
  job.valid = false
end


-- remove this code after debugging
--generate_ai_tags_and_attach(dt.gui.selection())

--local function generate_

-- defensive cleanup: remove any previous registration with the same name/type
pcall(dt.destroy_event, EVENT_NAME, EVENT_TYPE)

dt.register_event(EVENT_NAME, -- event name (unique id)
                  EVENT_TYPE, -- event type
                  function(event, shortcut)
                        generate_ai_tags_and_attach(dt.gui.selection())
                  end, _("attach AI tags and title to the images") -- label shown in Shortcuts prefs
)

return script_data
